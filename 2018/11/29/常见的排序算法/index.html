<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>基础排序算法之swift | 虛無縹緲</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="最近稍微空闲，发现之前熟悉的基础排序和查找算法忘的差不多了，原理都还能说得清，动手就有些含糊了，所以就有了重新认识一下的想法，顺便复习一下数据结构。
1、快速排序算法快速排序在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环可以在大部分的架构上很有效率地被">
<meta property="og:type" content="article">
<meta property="og:title" content="基础排序算法之swift">
<meta property="og:url" content="http://xuwupiaomiao.com/2018/11/29/常见的排序算法/index.html">
<meta property="og:site_name" content="虛無縹緲">
<meta property="og:description" content="最近稍微空闲，发现之前熟悉的基础排序和查找算法忘的差不多了，原理都还能说得清，动手就有些含糊了，所以就有了重新认识一下的想法，顺便复习一下数据结构。
1、快速排序算法快速排序在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环可以在大部分的架构上很有效率地被">
<meta property="og:updated_time" content="2019-04-14T12:50:56.336Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基础排序算法之swift">
<meta name="twitter:description" content="最近稍微空闲，发现之前熟悉的基础排序和查找算法忘的差不多了，原理都还能说得清，动手就有些含糊了，所以就有了重新认识一下的想法，顺便复习一下数据结构。
1、快速排序算法快速排序在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环可以在大部分的架构上很有效率地被">
  
    <link rel="alternate" href="/atom.xml" title="虛無縹緲" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">虛無縹緲</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">你开心就好呢还是我开心就好呢</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xuwupiaomiao.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-常见的排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/29/常见的排序算法/" class="article-date">
  <time datetime="2018-11-28T16:00:00.000Z" itemprop="datePublished">2018-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      基础排序算法之swift
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近稍微空闲，发现之前熟悉的基础排序和查找算法忘的差不多了，原理都还能说得清，动手就有些含糊了，所以就有了重新认识一下的想法，顺便复习一下数据结构。</p>
<h1 id="1、快速排序算法"><a href="#1、快速排序算法" class="headerlink" title="1、快速排序算法"></a>1、快速排序算法</h1><p>快速排序在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。<br>快速排序使用分治法策略来把一个串行分为两个子串行。<br><a id="more"></a></p>
<h2 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h2><p>1 、从数列中挑出一个元素，称为 “基准”，<br>2、 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作。<br>3 、递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<h2 id="code："><a href="#code：" class="headerlink" title="code："></a>code：</h2><pre><code>  /**
 * 快速排序
 *
 */
func quickSort(array: inout [Int], leftIndex: Int, rightIndex: Int) {
    if leftIndex &gt;= rightIndex  {
        return
    }
    let pivotIndex = quickSortPartition(array: &amp;array, pivotIndex: leftIndex, endIndex: rightIndex)
    //左边部分快排
    quickSort(array: &amp;array, leftIndex: leftIndex, rightIndex: pivotIndex - 1)
    //右边部分快排
    quickSort(array: &amp;array, leftIndex: pivotIndex + 1, rightIndex: rightIndex)
}

/**
 * 分区
 * @params pivotIndex 基准开始的索引
 * @params endIndex   截止索引
 * @return    基准最后的索引
 */
func quickSortPartition(array: inout [Int], pivotIndex: Int, endIndex: Int) -&gt; Int {
    var currentIndex = pivotIndex + 1
    var currentPivotIndex = pivotIndex
    let pivotParma = array[pivotIndex]
    while currentIndex &lt;= endIndex{
        if pivotParma &gt; array[currentIndex] {
            let currentParma = array[currentIndex]
            array.remove(at: currentIndex)
            array.insert(currentParma, at: (pivotIndex &gt; 0 ? pivotIndex - 1 : 0))
            currentPivotIndex += 1
        }
        currentIndex += 1
    }
    return currentPivotIndex
}
</code></pre><h1 id="2、堆排序算法"><a href="#2、堆排序算法" class="headerlink" title="2、堆排序算法"></a>2、堆排序算法</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br>堆排序的平均时间复杂度为Ο(nlogn) 。</p>
<h2 id="算法步骤：-1"><a href="#算法步骤：-1" class="headerlink" title="算法步骤："></a>算法步骤：</h2><p>1、创建一个堆H[0..n-1]<br>2、把堆首（最大值）和堆尾互换<br>3、 把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置<br>4、 重复步骤2，直到堆的尺寸为1</p>
<h2 id="code：-1"><a href="#code：-1" class="headerlink" title="code："></a>code：</h2><pre><code>//MARK:func Heapsort(array: inout [Int]) {
    //1.构建大顶堆
    var index = array.count / 2 - 1
    while index &gt;= 0 {
        //从第一个非叶子结点从下至上，从右至左调整结构
        adjustHeap(array: &amp;array, inde: index, length: array.count)
        index -= 1
    }
    //2.调整堆结构+交换堆顶元素与末尾元素
    var j = array.count - 1
    while j &gt; 0 {
        array.swapAt(0, j)//将堆顶元素与末尾元素进行交换
        adjustHeap(array: &amp;array, inde: 0, length: j)//重新对堆进行调整
        j -= 1
    }
}
//调整堆
func adjustHeap(array: inout [Int], inde: Int, length: Int) {
    var index = inde;
    var tem = array[index]
    var curentIndex = index * 2 + 1
    while curentIndex &lt; length {
        if curentIndex + 1 &lt; length &amp;&amp; array[curentIndex] &lt; array[curentIndex + 1] {
            curentIndex += 1;
        }
        if array[curentIndex] &gt; tem {
            array.swapAt(index, curentIndex)
        }else{
            break
        }
        index = curentIndex
        tem = array[index];
        curentIndex = curentIndex * 2 + 1
    }
}
</code></pre><h1 id="3、归并排序"><a href="#3、归并排序" class="headerlink" title="3、归并排序"></a>3、归并排序</h1><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。</p>
<h2 id="算法步骤：-2"><a href="#算法步骤：-2" class="headerlink" title="算法步骤："></a>算法步骤：</h2><p>1、 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>2、 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>3、 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>4、 重复步骤3直到某一指针达到序列尾<br>5、 将另一序列剩下的所有元素直接复制到合并序列尾</p>
<h1 id="4、冒泡排序"><a href="#4、冒泡排序" class="headerlink" title="4、冒泡排序"></a>4、冒泡排序</h1><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p>
<h2 id="算法步骤：-3"><a href="#算法步骤：-3" class="headerlink" title="算法步骤："></a>算法步骤：</h2><p>冒泡排序算法的原理如下：<br>     比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>     对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>     针对所有的元素重复以上的步骤，除了最后一个。<br>     持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<h2 id="code：-2"><a href="#code：-2" class="headerlink" title="code："></a>code：</h2><pre><code>//MARK: 冒泡排序
func bubbleSort(array: inout [Int]) {
    let n = array.count - 2
    for i in 0 ... n {
        for j in 0 ... (n - i) {
            if array[j] &gt; array[j + 1]  {
                array.swapAt(j, j + 1)
            }
        }
    }
}
</code></pre><h1 id="5、希尔排序"><a href="#5、希尔排序" class="headerlink" title="5、希尔排序"></a>5、希尔排序</h1><p>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h2 id="算法步骤：-4"><a href="#算法步骤：-4" class="headerlink" title="算法步骤："></a>算法步骤：</h2><p>1、取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；<br>2、取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量<br>=1(&lt;…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</p>
<h2 id="code：-3"><a href="#code：-3" class="headerlink" title="code："></a>code：</h2><pre><code>//MARK: 希尔排序
func shellSort(array: inout [Int]) {
    //增量
    var increment = array.count / 2
    while increment &gt; 0 {
        for i in 0 ... increment - 1 {
            var a = i
            //每次增量进行直接插入排序
            while a &lt; array.count {
                var currentINC = increment;
                while a + currentINC &lt; array.count {
                    if array[a] &gt; array[a + currentINC]  {
                        array.swapAt(a, a + currentINC)
                    }
                    currentINC += increment
                }
                a += increment
            }
        }
        increment = increment / 2
    }
}
</code></pre><p>这是自己的拙见，欢迎指正，🙏。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuwupiaomiao.com/2018/11/29/常见的排序算法/" data-id="cjul8d0a60001egj6x3cxv5m0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/04/14/configs/sorts/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2017/04/20/iOS音频pcm文件opus格式压缩/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">iOS音频pcm文件opus格式压缩</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/01/">一月 1970</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/14/configs/sorts/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/11/29/常见的排序算法/">基础排序算法之swift</a>
          </li>
        
          <li>
            <a href="/2017/04/20/iOS音频pcm文件opus格式压缩/">iOS音频pcm文件opus格式压缩</a>
          </li>
        
          <li>
            <a href="/2017/04/20/自定义相机，截取需要的部分存储到相册/">自定义相机，截取需要的部分存储到相册</a>
          </li>
        
          <li>
            <a href="/2017/04/06/文本中获取想要的内容添加点击事件/">文本中获取想要的内容添加点击事件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 虛無縹緲<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>