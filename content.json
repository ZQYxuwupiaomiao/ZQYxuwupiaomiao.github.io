[{"date":"2019-04-14T13:20:37.983Z","path":"2019/04/14/configs/sorts/","text":"{\"\":[\"常见的排序算法.md\",\"文本中获取想要的内容添加点击事件.md\",\"个人博客之初搭建.md\",\"自定义相机，截取需要的部分存储到相册.md\",\"ios音频pcm文件opus格式压缩.md\"],\"__positions\":{\"个人博客之初搭建.md\":3,\"自定义相机，截取需要的部分存储到相册.md\":4,\"文本中获取想要的内容添加点击事件.md\":2,\"ios音频pcm文件opus格式压缩.md\":5,\"常见的排序算法.md\":1},\"__raw_positions\":{\"个人博客之初搭建.md\":3,\"自定义相机，截取需要的部分存储到相册.md\":4,\"文本中获取想要的内容添加点击事件.md\":2,\"ios音频pcm文件opus格式压缩.md\":5,\"常见的排序算法.md\":1}}","tags":[]},{"date":"2018-11-28T16:00:00.000Z","path":"2018/11/29/常见的排序算法/","text":"最近稍微空闲，发现之前熟悉的基础排序和查找算法忘的差不多了，原理都还能说得清，动手就有些含糊了，所以就有了重新认识一下的想法，顺便复习一下数据结构。 1、快速排序算法快速排序在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。快速排序使用分治法策略来把一个串行分为两个子串行。 算法步骤：1 、从数列中挑出一个元素，称为 “基准”，2、 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作。3 、递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。 code： /** * 快速排序 * */ func quickSort(array: inout [Int], leftIndex: Int, rightIndex: Int) { if leftIndex &gt;= rightIndex { return } let pivotIndex = quickSortPartition(array: &amp;array, pivotIndex: leftIndex, endIndex: rightIndex) //左边部分快排 quickSort(array: &amp;array, leftIndex: leftIndex, rightIndex: pivotIndex - 1) //右边部分快排 quickSort(array: &amp;array, leftIndex: pivotIndex + 1, rightIndex: rightIndex) } /** * 分区 * @params pivotIndex 基准开始的索引 * @params endIndex 截止索引 * @return 基准最后的索引 */ func quickSortPartition(array: inout [Int], pivotIndex: Int, endIndex: Int) -&gt; Int { var currentIndex = pivotIndex + 1 var currentPivotIndex = pivotIndex let pivotParma = array[pivotIndex] while currentIndex &lt;= endIndex{ if pivotParma &gt; array[currentIndex] { let currentParma = array[currentIndex] array.remove(at: currentIndex) array.insert(currentParma, at: (pivotIndex &gt; 0 ? pivotIndex - 1 : 0)) currentPivotIndex += 1 } currentIndex += 1 } return currentPivotIndex } 2、堆排序算法堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序的平均时间复杂度为Ο(nlogn) 。 算法步骤：1、创建一个堆H[0..n-1]2、把堆首（最大值）和堆尾互换3、 把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置4、 重复步骤2，直到堆的尺寸为1 code：//MARK:func Heapsort(array: inout [Int]) { //1.构建大顶堆 var index = array.count / 2 - 1 while index &gt;= 0 { //从第一个非叶子结点从下至上，从右至左调整结构 adjustHeap(array: &amp;array, inde: index, length: array.count) index -= 1 } //2.调整堆结构+交换堆顶元素与末尾元素 var j = array.count - 1 while j &gt; 0 { array.swapAt(0, j)//将堆顶元素与末尾元素进行交换 adjustHeap(array: &amp;array, inde: 0, length: j)//重新对堆进行调整 j -= 1 } } //调整堆 func adjustHeap(array: inout [Int], inde: Int, length: Int) { var index = inde; var tem = array[index] var curentIndex = index * 2 + 1 while curentIndex &lt; length { if curentIndex + 1 &lt; length &amp;&amp; array[curentIndex] &lt; array[curentIndex + 1] { curentIndex += 1; } if array[curentIndex] &gt; tem { array.swapAt(index, curentIndex) }else{ break } index = curentIndex tem = array[index]; curentIndex = curentIndex * 2 + 1 } } 3、归并排序归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。 算法步骤：1、 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列2、 设定两个指针，最初位置分别为两个已经排序序列的起始位置3、 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置4、 重复步骤3直到某一指针达到序列尾5、 将另一序列剩下的所有元素直接复制到合并序列尾 4、冒泡排序冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。 算法步骤：冒泡排序算法的原理如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 code：//MARK: 冒泡排序 func bubbleSort(array: inout [Int]) { let n = array.count - 2 for i in 0 ... n { for j in 0 ... (n - i) { if array[j] &gt; array[j + 1] { array.swapAt(j, j + 1) } } } } 5、希尔排序希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 算法步骤：1、取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；2、取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量=1(&lt;…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。 code：//MARK: 希尔排序 func shellSort(array: inout [Int]) { //增量 var increment = array.count / 2 while increment &gt; 0 { for i in 0 ... increment - 1 { var a = i //每次增量进行直接插入排序 while a &lt; array.count { var currentINC = increment; while a + currentINC &lt; array.count { if array[a] &gt; array[a + currentINC] { array.swapAt(a, a + currentINC) } currentINC += increment } a += increment } } increment = increment / 2 } } 这是自己的拙见，欢迎指正，🙏。","tags":[]},{"date":"2017-04-20T06:48:32.000Z","path":"2017/04/20/iOS音频pcm文件opus格式压缩/","text":"因做语音在线识别就了解一下pcm做opus压缩。opus是一种声音编码格式，Opus的前身是celt编码器。是由IETF开发，适用于网络上的实时声音传输，标准格式为RFC 6716。这是一种有损的声音编码格式。 #一、首先获取opus压缩的iOS库先从GitHub下载国外大神Opus-iOS编译工程，然后修改需要运行的脚本文件 （build-libopus.sh） ##1、一般需要修改这几个地方 VERSION=”1.3” ##当前编译opus版本基本上不用修改SDKVERSION=”10.2” ##你用的xcode sdk版本MINIOSVERSION=”8.0” ##最低支持的iOS系统 ##2、在 build-libopus.sh 文件中107行 的脚本代码 EXTRA_CONFIG=”” 修改为 EXTRA_CONFIG=”–host=x86_64” 注意,这个地方是和电脑的CPU相关的 ##3、最后编译脚本生成需要的库； $ ./build-libopus.sh 运行成功下面文件夹里面的就是需要的库，至于怎么放进工程随自己喜好。 #二、获取pcm（纯语音数据）语音数据获取pcm格式的语音数据,这里的pcm数据的采样率要注意要和后面opus压缩的采样率一样。 #三、opus压缩pcm认识几个参数 ##1、设置参数 enc = opus_encoder_create(kDefaultSampleRate, 1, OPUS_APPLICATION_VOIP, &amp;error);//(采样率，声道数,,) dec = opus_decoder_create(kDefaultSampleRate, 1, &amp;error); opus_encoder_ctl(enc, OPUS_SET_BITRATE(kDefaultSampleRate));//比特率 opus_encoder_ctl(enc, OPUS_SET_BANDWIDTH(OPUS_AUTO));//OPUS_BANDWIDTH_NARROWBAND 宽带窄带 opus_encoder_ctl(enc, OPUS_SET_VBR(0)); opus_encoder_ctl(enc, OPUS_SET_VBR_CONSTRAINT(1)); opus_encoder_ctl(enc, OPUS_SET_COMPLEXITY(8));//录制质量 1-10 opus_encoder_ctl(enc, OPUS_SET_PACKET_LOSS_PERC(0)); opus_encoder_ctl(enc, OPUS_SET_SIGNAL(OPUS_SIGNAL_VOICE));//信号 ##2、压缩函数的函数 //传入要压缩的数据 -(NSData *)encodePCMData:(NSData*)data{ return [self encode:(short *)[data bytes] length:[data length]]; } -(NSData *)encode:(short *)pcmBuffer length:(NSInteger)lengthOfShorts{ opus_int16 *PCMPtr = pcmBuffer; int PCMSize = (int)lengthOfShorts / sizeof(opus_int16); opus_int16 *PCMEnd = PCMPtr + PCMSize; NSMutableData *mutData = [NSMutableData data]; unsigned char encodedPacket[MAX_PACKET_BYTES]; // 记录opus块大小 OPUS_DATA_SIZE_T encodedBytes = 0; while (PCMPtr + WB_FRAME_SIZE &lt; PCMEnd) { encodedBytes = opus_encode(enc, PCMPtr, WB_FRAME_SIZE, encodedPacket, MAX_PACKET_BYTES); if (encodedBytes &lt;= 0) { return nil; } // 大端转小端 这个要根据解析要求是大段还是小段存储 // encodedBytes = CFSwapInt32HostToBig(encodedBytes) // 保存opus块大小 [mutData appendBytes:&amp;encodedBytes length:sizeof(encodedBytes)]; // 保存opus数据 [mutData appendBytes:encodedPacket length:encodedBytes]; PCMPtr += WB_FRAME_SIZE; } return mutData.length &gt; 0 ? mutData : nil; } 这是自己的拙见，欢迎指正，🙏。","tags":[]},{"date":"2017-04-20T06:48:32.000Z","path":"2017/04/20/自定义相机，截取需要的部分存储到相册/","text":"最近有个需求需要在拍照时截取线框的部分存储在相册，就写了个demo。这是相框的位置设定 CGFloat height = self.bounds.size.height; CGFloat width = self.bounds.size.width; UIImageView *imageV = [[UIImageView alloc] initWithFrame:CGRectMake((width - width * 3 / 4) / 2, height * 0.3, width * 3 / 4 , width * 3 / 12)]; imageV.clipsToBounds = YES; imageV.layer.borderColor = [UIColor whiteColor].CGColor; imageV.layer.borderWidth = 0.5; [self addSubview:imageV]; 按说截取的frame要和这个frame一致，但是后面把image放到屏幕为了清晰度用的是 UIGraphicsBeginImageContextWithOptions(size,YES,[UIScreen mainScreen].scale); 而不是 UIGraphicsBeginImageContext(size); 所以截取位置的frame _imageRect就要用相应的 CGFloat height2 = height * [UIScreen mainScreen].scale;CGFloat width2 = width * [UIScreen mainScreen].scale;_imageRect = CGRectMake((width2 - width2 * 3 / 4) / 2, height2 * 0.3, width2 * 3 / 4 , width2 * 3 / 12); 这是image放到屏幕的函数 +(UIImage*)image:(UIImage *)image scaleToSize:(CGSize)size{ // 得到图片上下文，指定绘制范围// UIGraphicsBeginImageContext(size); UIGraphicsBeginImageContextWithOptions(size,YES,[UIScreen mainScreen].scale); // 将图片按照指定大小绘制 [image drawInRect:CGRectMake(0, 0, size.width, size.height)]; // 从当前图片上下文中导出图片 UIImage* scaledImage = UIGraphicsGetImageFromCurrentImageContext(); // 当前图片上下文出栈 UIGraphicsEndImageContext(); // 返回新的改变大小后的图片 return scaledImage;} 截取image的函数 +(UIImage *)imageFromImage:(UIImage *)image inRect:(CGRect)rect{ //将UIImage转换成CGImageRef CGImageRef sourceImageRef = [image CGImage]; //按照给定的矩形区域进行剪裁 CGImageRef newImageRef = CGImageCreateWithImageInRect(sourceImageRef, rect); //将CGImageRef转换成UIImage UIImage *newImage = [UIImage imageWithCGImage:newImageRef]; //返回剪裁后的图片 return newImage;} 这是自己的拙见，欢迎指正，🙏。","tags":[]},{"date":"2017-04-06T08:53:32.000Z","path":"2017/04/06/文本中获取想要的内容添加点击事件/","text":"文本中获取想要的内容并添加点击事件最近项目添加新需求，需要获取文本中的链接，标注并跳转webView,就撸了个简单的demo，随后再修改，是用swift写的。github demo 1、把工具类倒入项目添加需要的代码 把 ZQYTapLabbel.swift ZQYExtension.swift WPAttributedStyleAction.swift这三个类倒入项目，创建ZQYTapLabbel即可如下： override func viewDidLoad() { super.viewDidLoad() self.title = &quot;根视图&quot; //创建ZQYTapLabbel这个lable标记需要到内容并添加了点击事件 let label = ZQYTapLabbel(frame: CGRect(x: 50,y: 100,width: 300,height: 100)); label.numberOfLines = 0; let string:NSString = &quot;www.baidu.com你猜这是啥，132343243.45t5t5猜对有奖啊，https://www.github.com&quot;; label.text = string as String; label.attributedText = label.text?.attributedWithStyleBook(); self.view.addSubview(label); //接受通知监听 NotificationCenter.default.addObserver(self, selector:#selector(didMsgRecv(notification:)), name: NSNotification.Name(rawValue: &quot;sendInfoToVC&quot;), object: nil) } //处理事件 func didMsgRecv(notification:NSNotification){ let webView = ZQYWebViewController() webView.url = notification.object as? String self.navigationController?.pushViewController(webView, animated: true) } 2、在ZQYExtension.swift类中修改，添加自己需要的需求只需要修改String扩展中attributedWithStyleBook函数,代码加注释如下： func attributedWithStyleBook() -&gt; NSAttributedString { let mStr = (self as NSString).mutableCopy() let attributeString = NSMutableAttributedString(string:mStr as! String) do { /* * 我这里是用正则匹配连接，可能不太全面，如有好的请告知。 * 若是想标注某个词或者某个字就把下面的正则表达式换成需要标注的内容 * 例如 regulaStr = &quot;你猜这是啥&quot; */ let regulaStr = &quot;((http[s]{0,1}|ftp)://[a-zA-Z0-9\\\\.\\\\-]+\\\\.([a-zA-Z]{2,4})(:\\\\d+)?(/[a-zA-Z0-9\\\\.\\\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)|(www.[a-zA-Z0-9\\\\.\\\\-]+\\\\.([a-zA-Z]{2,4})(:\\\\d+)?(/[a-zA-Z0-9\\\\.\\\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)&quot;; let regex = try NSRegularExpression(pattern: regulaStr, options:.caseInsensitive) let arrayOfAllMatches = regex.matches(in: self, options: NSRegularExpression.MatchingOptions(rawValue: 0), range: NSRange(location:0,length:(self as NSString).length)) arrayOfAllMatches.forEach({ (match) in let subStringForMatch = (self as NSString).substring(with: match.range) //在这个字典做自己特殊修改，添加自己想要的属性 let styleDic = [&quot;body&quot;:UIFont(name:&quot;HelveticaNeue&quot;,size:20.0)!, subStringForMatch:WPAttributedStyleAction.styledActionWithAction { /** * 为需要标示的内容绑定了点击事件 * 若是点击的区域是标记包含的区域在这里做处理你可以用自己想要的方式处理，我这里图省事和方便就用KVO，可能性能不太好。 */ NotificationCenter.default.post(name:NSNotification.Name(rawValue: &quot;sendInfoToVC&quot;), object: subStringForMatch, userInfo: nil) }, &quot;link&quot;:UIColor.orange ] as [String : Any] let bodyStyle = styleDic[&quot;body&quot;] if let bodyStyle = bodyStyle as? NSObject{ self.styleAttributedString(attributeString: attributeString, range: NSRange(location: 0, length: attributeString.length), style: bodyStyle, styleBook: styleDic as NSDictionary) } if let style = styleDic[subStringForMatch] as? NSObject{ self.styleAttributedString(attributeString: attributeString, range: match.range, style: style, styleBook: styleDic as NSDictionary) } }) } catch { } return attributeString; }","tags":[]},{"date":"1970-01-01T00:33:37.000Z","path":"1970/01/01/个人博客之初搭建/","text":"个人博客之初搭建最近买了个域名，利用GitHub，搭建个人博客。 一、GitHub设置创建仓库 1注意：仓库的名称，必须是：你的用户名.github.io 二、关联GitHub这里有介绍了两种方式，一种是自己用html页面，这就需要扎实的html功底，另一种一个快速、简洁且高效的博客框架Hexo，它使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本人才疏学浅就用了第二种。 （一）、html1、把仓库clone到本地更新内容命令行进入硬盘上任意一个文件夹，然后执行 git clone https://github.com/你的用户名/你的用户名.github.io.git 2、创建CNAME文件进入刚才clone到本地的XXXXX.github.io文件夹中新建一个CNAME文件（无后缀名），然后用文本编辑器打开，在首行添加你的网站域名，如xxxx.com，注意前面没有http://，也没有www。 （为了看到效果我这里随便写了个html文件） 3、上传到github把文件夹下的文件提交到git git add .git commit -m “更新index.html”git push 提交到github成功后就可以在浏览器查看网址：http://你的用户名.github.io （二）、Hexo1、安装Hexo安装Hexo要首先安装Node.js和Git，安装好之后，就可以用npm来安装Hexo。1$ npm install -g hexo-cli 2、Hexo部署Hexo安装好之后，开始部署。打开终端，进入到你想存放关于Hexo文件的文件夹，执行一下命令123$ hexo init yourName //yourName就是存放文件的文件夹，这句话会帮你创建文件夹$ cd yourName$ npm install 下面就需要修改配置信息与Github pages进行关联，进入yourName文件夹，打开_config.yml文件，并滚动到最下面添加如下配置信息123type: gitrepository: https://github.com/zqyxuwupiaomiao/zqyxuwupiaomiao.github.io.gitbranch: master 注意：这里每个冒号下面一定要有一个空格，不然会出错。到此你使用终端，然后进入到你的站点文件夹使用hexo s命令，如果成功会打印类似Hexo is running at http://localhost:4000/. Press Ctrl+C to stop的一句话，再打开你的浏览器输入localhost:4000地址就可以看到效果。 2、部署到GitHub下面还需要在你的hexo目录里的source目录下添加一个CNAME文件，不带后缀，一定要是大写的CNAME，用文本编辑器打开CNAME，里面添加你的域名信息（不加http://） 如下图 本地跑起来后就需要部署到GitHub pages，所以你就需要在你的站点里使用终端命令进行部署123$ hexo clean$ hexo g$ hexo d 命令详解，第一条是清楚缓存，第二条命令是生成本地发布文件夹，第三条命令才是最后的发布到GitHub pages上。更多的Hexo命令操作请参考官方文档即可。 2、Hexo主题更多个性主题点这里 三、域名解析 （1）先添加一个CNAME记录类型，主机记录写@，后面记录值写上你的http://xxxx.github.io（2）再添加一个CNAME记录类型，主机记录写www，后面记录值也是http://xxxx.github.io这样别人用www和不用www都能访问你的网站（其实www的方式，会先解析成http://xxxx.github.io，然后根据CNAME再变成http://xxx.com，即中间是经过一次转换的）。 这里用的是CNAME别名记录，也有人使用A记录，后面的记录值是写github page里面的IP地址，但有时候IP地址会更改，导致最后解析不正确，所以还是推荐用CNAME别名记录要好些，不建议用IP。 A记录是直接解析到空间IP地址；CNAME是解析到别名；MX是电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器，是设置企业邮箱的;NS是指DNS,用默认的就行,一般不用修改；TXT一般指为某个主机名或域名设置的说明，是企业邮箱的辅助设置。 （3）等十分钟左右，用你自己域名访问下试试","tags":[]}]